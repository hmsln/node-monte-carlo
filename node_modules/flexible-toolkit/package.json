{
  "name": "flexible-toolkit",
  "version": "1.0.3",
  "description": "Utility functions for node.js, as extension of native types and/or as standalone functions",
  "keywords": [
    "utilities",
    "utility",
    "clone",
    "array manipulation"
  ],
  "main": "index.js",
  "scripts": {
    "test": "jasmine-node test"
  },
  "dependencies": {
    "custom-error-factory": "x",
    "suit-yourself": "x"
  },
  "devDependencies": {
    "jasmine-node": "^1.14.5"
  },
  "engines": {
    "node": "^4.1.2"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hmsln/flexible-toolkit.git"
  },
  "author": {
    "name": "Hubert Maslin",
    "email": "hubert.maslin@gmail.com"
  },
  "license": "MIT",
  "readme": "# Flexible toolkit\n\n```flexible-toolkit``` is an open source module that exposes utility functions (for string, object or array manipulation).\nThese utility functions are gathered as submodules that can be imported one by one. You can specify, for each module, whether\nits functions should be imported as standalone or as extensions of native objects.\n\n## Installation\n\nInstall with the command ```npm install flexible-toolkit```\n\n## Importing submodules\n\nTo import all submodules as both extension of native objects and standalone functions:\n\n```javascript\nvar toolkit = require('flexible-toolkit.js')();\n\n/*standalone functions from the array, string and scheduled-action submodules are in toolkit.array, toolkit.string and toolkit['scheduled-action']*/\n\n//Let's copy an array using both Array.prototype.copy and the standalone toolkit.array.copy\nvar testArr = [1, 2, 3];\n\n//copy using Array.prototype.copy\nvar testArrCopy1 = testArr.prototype.copy();\n\n//copy arr1 using the standalone function copy attached to toolkit.array\nvar testArrCopy2 = toolkit.array.copy(testArr);\n```\n\nTo import all submodules as extension of native objects:\n\n```javascript\nvar toolkit = require('flexible-toolkit.js')(true);\n```\n\nTo import all submodules as standalone functions:\n\n```javascript\nvar toolkit = require('flexible-toolkit.js')(false, true);\n```\n\nYou can also specify which submodules should be imported and how.\n\n```javascript\nvar toolkit = require('flexible-toolkit.js')([\n    {\n       name: 'array',\n       arguments: [true, true]//import as native types extension and standalone functions\n    },\n    {\n        name: 'object',\n        arguments: [false, true] //only import as standalone functions\n    },\n    {\n        name: 'scheduled-action'\n    },\n    {\n        name: 'string',\n        arguments: [true, false] //only import as native types extension\n    },\n    {\n        name 'arithmetics'\n    }\n]);\n```\n\nIf you do not want to import a module, just omit it from the toRequire parameter:\n```javascript\nvar toolkit = require('flexible-toolkit.js')([\n    {\n       name: 'array',\n       arguments: [true, true]//import as native types extension and standalone functions\n    },\n    {\n        name: 'scheduled-action'\n    },\n    {\n        name: 'string',\n        arguments: [true, false] //only import as native types extension\n    }\n    //arithmetics and object have been omitted and thus will not be imported\n]);\n```\n\nIf you have imported some submodules as standalone functions, ```require('flexible-toolkit.js')(submodulesToRequire)``` returns an object with the submodules attached.\n\n```javascript\nvar toolkit = require('flexible-toolkit.js')([\n    {\n       name: 'array',\n       arguments: [true, true]//import as native types extension and standalone functions\n    },\n    {\n        name: 'scheduled-action'\n    },\n    {\n        name: 'string',\n        arguments: [true, false] //only import as native types extension\n    }\n    //arithmetics and object have been omitted and thus will not be imported\n]);\n``` \n\nNote: the submodule loader used for importation is [suit-yourself](https://github.com/hmsln/suit-yourself). It's used as a dependency by this package.\n\n## Overview of the submodules\n\nAvailable submodules are:\n\n+ ```array```, ```object``` and ```string```, which can be imported either as extensions of native objects, or as standalone functions.\n\n+ ```arithmetics``` and ```scheduled-action```, which can only be imported as standalone functions.\n\n\n#### arithmetics\n**randStr([length])** - Generate a random string of length ```length``` with characters 0-9a-zA-Z (default length is 32).\n```javascript\nvar r = toolkit.arithmetics.randStr();\nconsole.log(r);\n//'HJD8PXL7uaaF7ze8YDaqPO8XxWkvQfSE'\n```\n#### array\n**copy()** - Shallow copies the array.\n```javascript\nvar testArr = [1, 2, 3, 4, 5];\nvar arr = testArr.copy(); // as extension of Array.prototype\n//or as standalone function: var arr = toolkit.array.copy(testArr);\nconsole.log(arr);\n//[1, 2, 3, 4, 5]\n```\n**move(old_index, new_index)** - Move an element from old_index to new_index, mutating the array it's applied to.\n```javascript\nvar testArr = [1, 2, 3, 4, 5];\ntestArr.move(1, 2); // as extension of Array.prototype\n//or as standalone function: toolkit.array.move(testArr, 1, 2);\nconsole.log(testArr);\n//[1, 3, 2, 4, 5] (element at index 1 has been moved to index 2)\n```\n**concatNew(arr)** - Concat elements of arr that are not present in the array it's applied to; Array.prototype.indexOf is used for comparison.\n```javascript\nvar testArr = [1, 2, 3, 4, 5];\nvar testArr2 = [5, 6, 7];\ntestArr.concatNew(testArr2); // as extension of Array.prototype\n//or as standalone function: toolkit.array.concatNew(testArr, testArr2);\nconsole.log(testArr);\n//[1, 2, 3, 4, 5, 6, 7]\n```\n**without(values, [mutate])** - remove from the array it's applied to the elements from the ```values``` array, mutating the array it's applied to.\n```javascript\nvar testArr = [1, 2, 3, 4, 5];\nvar testArr2 = [5, 6, 7];\ntestArr.without(testArr2, true);\n//or as standalone function: toolkit.array.without(testArr, testArr2, true);\nconsole.log(testArr);\n//[1, 2, 3, 4]\n```\n**containsElementsOfArray(arr)** - returns true if arr and the array it's applied to have some elements in common. Array.prototype.indexOf is used for comparison.\n```javascript\nvar testArr = [1, 2, 3, 4, 5];\nvar testArr2 = [5, 6, 7];\nvar bool = testArr.containsElementsOfArray(testArr2);\n//or as standalone function: toolkit.array.containsElementsOfArray(testArr, testArr2);\nconsole.log(bool);\n//true\n```\n#### object\n**shallowCopy** - copies enumerable properties of an object, including its subobjects, and its protoype chain; Warning! subobjects are copied as references, and are shared with the origin object.\n```javascript\nvar makeObj = function () {\n    this.a = 1;\n    this.b = {\n        c: 2\n    };\n}\n\nvar obj = new makeObj();\nvar copy = obj.shallowCopy();\n//or as standalone function: var copy = toolkit.object.shallowCopy(obj);\n```\n**deepCopy** - copies an object, including its subobjects, and its protoype chain. Subobjects are recursively copied as values, and aren't shared with the origin object. Two caveats: circular references within object will lead to infinite recursion (will solve this as soon as I have the time); and doesn't copy closures' scopes (you just can't do that).\n```javascript\nvar makeObj = function () {\n    this.a = 1;\n    this.b = {\n        c: 2\n    };\n}\n\nvar obj = new makeObj();\nvar copy = obj.deepCopy();\n//or as standalone function: var copy = toolkit.object.deepCopy(obj);\n```\n#### string\n**capitalize** - the first character of the string is set in uppercase.\n```javascript\nvar testStr = 'simba';\ntestStr.capitalize();\n//or as standalone function: toolkit.string.capitalize(testStr);\nconsole.log(testStr);\n//Simba\n```\n**uncapitalize** - the first character of the string is set in lowercase.\n```javascript\nvar testStr = 'Simba';\ntestStr.capitalize();\n//or as standalone function: toolkit.string.uncapitalize(testStr);\nconsole.log(testStr);\n//simba\n```\n#### scheduled-action\nAllows you to schedule a allback to execute once some conditions have been met.\n```javascript\n//create callback function, setting bool as\nvar f = function(){\n\tconsole.log('callback has been executed!');\n}\n\n//constructor of a scheduledAction object\nvar s = new toolkit['scheduled-action'](['condition1', 'condition2'], f);\n//toolkit['scheduled-action'].setTrue(condition) - set as true one of the conditions of the object\ns.setTrue('condition1');\ns.setTrue('condition2');\n//'callback has been executed!'\n```\n\n## Tests\n\nThe test spec is in ```/test/test.spec.js```, and the test suite is ```jasmine-node```, which you can install by running ```npm install -g jasmine-node```\n\nYou can run the tests with the commands ```jasmine-node test``` or ```npm run test```\n\n## To do\nIn ```object.deepCopy```: detect circular references and prevent fucntion from entering in infinite recursion when encountering circular references. I'll do that as soon as I have the time.\n\nAdd typechecking to make some functions more robust to programmer error (throw TypeError so logging is easier).\n\nSome of the submodules might be enriched with new functions. Other submodules could be added. I'm thinking of adding\nset manipulation operations such as ```intersect```, ```union``` or ```difference``` for ```Set``` and ```WeakSet``` types.\n\nThank you for reading this far. If you have any bugs to report or improvements to suggest you can send me an email at hubert.maslin@gmail.com.",
  "readmeFilename": "README.md",
  "gitHead": "ce6be723ed9c3121061a79e77f0f5ba036b7dc60",
  "bugs": {
    "url": "https://github.com/hmsln/flexible-toolkit/issues"
  },
  "homepage": "https://github.com/hmsln/flexible-toolkit#readme",
  "_id": "flexible-toolkit@1.0.3",
  "_shasum": "70ecc2c218c9a606ee5be6734a299405f95fba97",
  "_from": "flexible-toolkit@>=1.0.3 <2.0.0"
}
